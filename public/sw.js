/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Declare self as ServiceWorkerGlobalScope
const sw = self;

// Precache all assets generated by Vite build
// This is the placeholder that Workbox will replace with the actual manifest
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Runtime caching for IQAir API
registerRoute(
  ({ url }) => url.origin === 'http://api.airvisual.com' || url.hostname === 'api.airvisual.com',
  new NetworkFirst({
    cacheName: 'iqair-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 30, // 30 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Runtime caching for Supabase edge functions
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ========================================
// PERIODIC BACKGROUND SYNC FOR AIR QUALITY
// ========================================

const SYNC_TAG = 'phri-air-quality-sync';
const DB_NAME = 'phri-db';
const STORE_NAME = 'phri';
const NOTIFICATION_TAG = 'phri-alert';

// Helper: Open IndexedDB
const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
  });
};

// Helper: Get notification settings from IndexedDB
const getNotificationSettings = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('notification-settings');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting notification settings:', error);
    return null;
  }
};

// Helper: Check if currently in quiet hours
const isQuietHours = (settings) => {
  if (!settings || !settings.enable_quiet_hours) return false;
  
  const now = new Date();
  const currentTime = now.getHours() * 60 + now.getMinutes();
  
  const [startHour, startMin] = settings.quiet_hours_start.split(':').map(Number);
  const [endHour, endMin] = settings.quiet_hours_end.split(':').map(Number);
  
  const startTime = startHour * 60 + startMin;
  const endTime = endHour * 60 + endMin;
  
  if (startTime <= endTime) {
    return currentTime >= startTime && currentTime < endTime;
  } else {
    // Crosses midnight
    return currentTime >= startTime || currentTime < endTime;
  }
};

// Helper: Get user's last known location from IndexedDB
const getLastLocation = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-location');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting last location:', error);
    return null;
  }
};

// Helper: Get user health profile from IndexedDB
const getHealthProfile = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('health-profile');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting health profile:', error);
    return null;
  }
};

// Helper: Save location to IndexedDB
const saveLocation = async (latitude, longitude, location) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-location',
      latitude,
      longitude,
      location,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving location:', error);
    return false;
  }
};

// Helper: Calculate distance between two coordinates (Haversine formula)
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return R * c; // Distance in meters
};

// Helper: Get current location using Geolocation API
const getCurrentLocation = async () => {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation not supported'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        });
      },
      (error) => {
        console.error('Geolocation error:', error);
        reject(error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000
      }
    );
  });
};

// Helper: Save air quality data to IndexedDB
const saveAirQualityData = async (data) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-air-quality',
      ...data,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving air quality data:', error);
    return false;
  }
};

// Fetch air quality data from edge function
const fetchAirQuality = async (latitude, longitude) => {
  try {
    // Use self.location to get the origin dynamically
    const baseUrl = self.location.origin;
    
    const response = await fetch(`${baseUrl}/.netlify/functions/get-air-quality`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ latitude, longitude })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching air quality:', error);
    return null;
  }
};

// Check if notification should be triggered based on AQI thresholds and settings
const shouldNotify = (aqi, userProfile, previousAqi, hasLocationChanged, settings) => {
  // Check quiet hours
  if (isQuietHours(settings)) {
    console.log('üîá In quiet hours, skipping notification');
    return { notify: false, reason: 'quiet_hours' };
  }
  
  // Get custom threshold from settings (default 100)
  const threshold = settings?.aqi_threshold || 100;
  
  // Calculate AQI change
  const aqiChange = previousAqi ? Math.abs(aqi - previousAqi) : 0;
  
  // Always notify on location change if AQI exceeds threshold
  if (hasLocationChanged && aqi > threshold) {
    return { notify: true, reason: 'location_change' };
  }
  
  // Notify if AQI is moderate or higher for users with health conditions
  if (userProfile?.conditions && userProfile.conditions.length > 0 && aqi > 50) {
    return { notify: true, reason: 'health_conditions' };
  }
  
  // Notify if AQI significantly increased (>25 points change) and exceeds threshold
  if (aqiChange > 25 && aqi > threshold) {
    return { notify: true, reason: 'aqi_spike' };
  }
  
  // Notify if AQI exceeds user's threshold
  if (aqi > threshold) {
    return { notify: true, reason: 'threshold_exceeded' };
  }
  
  return { notify: false, reason: null };
};

// Get AQI category and message
const getAQIMessage = (aqi) => {
  if (aqi <= 50) {
    return { 
      category: 'Good', 
      message: 'Good Air Quality',
      thai: '‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏î‡∏µ',
      color: '#00E400'
    };
  } else if (aqi <= 100) {
    return { 
      category: 'Moderate', 
      message: 'Moderate ‚Äì Sensitive groups be aware',
      thai: '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á ‚Äì ‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ß‡∏±‡∏á',
      color: '#FFFF00'
    };
  } else if (aqi <= 150) {
    return { 
      category: 'Unhealthy for Sensitive Groups', 
      message: 'Unhealthy for sensitive groups',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á',
      color: '#FF7E00'
    };
  } else if (aqi <= 200) {
    return { 
      category: 'Unhealthy', 
      message: 'Unhealthy ‚Äì Wear a mask outdoor',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#FF0000'
    };
  } else {
    return { 
      category: 'Very Unhealthy', 
      message: 'Very Unhealthy ‚Äì Avoid outdoor activities',
      thai: '‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#8F3F97'
    };
  }
};

// Show notification with vibration based on AQI
const showAirQualityNotification = async (aqi, location, reason) => {
  try {
    const aqiInfo = getAQIMessage(aqi);
    let title = '';
    let body = '';
    let vibrate = [300, 100, 300];
    let requireInteraction = false;
    
    if (aqi > 200) {
      title = 'üö® ‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢! ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å';
      body = `AQI ${aqi} - ${aqiInfo.thai}\n${location}`;
      vibrate = [500, 200, 500, 200, 500];
      requireInteraction = true;
    } else if (aqi > 150) {
      title = '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û';
      body = `AQI ${aqi} - ${aqiInfo.thai}\n${location}`;
      vibrate = [300, 100, 300, 100, 300];
      requireInteraction = true;
    } else if (aqi > 100) {
      title = '‚ö†Ô∏è ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\n${location}`;
    } else if (reason === 'location_change') {
      title = 'üìç ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà';
      body = `AQI ${aqi} - ${aqiInfo.thai}\n${location}`;
    } else if (reason === 'aqi_spike') {
      title = 'üìà ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\n${location}`;
      vibrate = [300, 100, 300, 100, 300];
    } else {
      title = `AQI ${aqi} - ${aqiInfo.category}`;
      body = `${aqiInfo.message}\n${location}`;
    }
    
    await sw.registration.showNotification(title, {
      body,
      icon: '/icon-192.png',
      badge: '/icon-192.png',
      tag: NOTIFICATION_TAG,
      vibrate,
      requireInteraction,
      data: { aqi, location, category: aqiInfo.category, reason, timestamp: Date.now() },
      actions: [
        { action: 'view', title: '‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î' },
        { action: 'dismiss', title: '‡∏õ‡∏¥‡∏î' }
      ]
    });
    
    console.log('‚úÖ Notification shown:', { aqi, location, category: aqiInfo.category, reason });
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

// Main periodic sync handler
const handlePeriodicSync = async () => {
  console.log('üîÑ Periodic sync started:', new Date().toISOString());
  
  try {
    // Get current location
    let currentLocation;
    try {
      currentLocation = await getCurrentLocation();
      console.log('‚úÖ Current location:', currentLocation);
    } catch (locError) {
      console.log('‚ö†Ô∏è Could not get current location, using last known');
      const lastLoc = await getLastLocation();
      if (!lastLoc?.latitude || !lastLoc?.longitude) {
        console.log('‚ùå No location data available');
        return;
      }
      currentLocation = {
        latitude: lastLoc.latitude,
        longitude: lastLoc.longitude
      };
    }
    
    // Get previous location and air quality data
    const previousLocationData = await getLastLocation();
    const previousAirQualityData = await saveAirQualityData({ id: 'last-air-quality' });
    
    // Calculate if location changed significantly (>500 meters)
    let hasLocationChanged = false;
    let distanceMoved = 0;
    if (previousLocationData?.latitude && previousLocationData?.longitude) {
      distanceMoved = calculateDistance(
        previousLocationData.latitude,
        previousLocationData.longitude,
        currentLocation.latitude,
        currentLocation.longitude
      );
      hasLocationChanged = distanceMoved > 500; // 500 meters threshold
      console.log(`üìç Distance moved: ${Math.round(distanceMoved)}m, Changed: ${hasLocationChanged}`);
    }
    
    // Fetch air quality data for current location
    const airQualityData = await fetchAirQuality(
      currentLocation.latitude,
      currentLocation.longitude
    );
    
    if (!airQualityData || !airQualityData.pm25) {
      console.log('‚ùå Failed to fetch air quality data');
      return;
    }
    
    console.log('‚úÖ Air quality data fetched:', airQualityData);
    
    // Save location and air quality to IndexedDB
    await saveLocation(
      currentLocation.latitude,
      currentLocation.longitude,
      airQualityData.location
    );
    
    await saveAirQualityData({
      pm25: airQualityData.pm25,
      aqi: airQualityData.aqi,
      location: airQualityData.location || 'Unknown',
      latitude: currentLocation.latitude,
      longitude: currentLocation.longitude
    });
    
    // Get user health profile
    const healthProfile = await getHealthProfile();
    
    // Get notification settings
    const notificationSettings = await getNotificationSettings();
    
    // Check if notification should be triggered based on AQI
    const notificationCheck = shouldNotify(
      airQualityData.aqi,
      healthProfile,
      previousAirQualityData?.aqi,
      hasLocationChanged,
      notificationSettings
    );
    
    if (notificationCheck.notify) {
      await showAirQualityNotification(
        airQualityData.aqi,
        airQualityData.location || '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô',
        notificationCheck.reason
      );
    } else if (notificationCheck.reason === 'quiet_hours') {
      console.log('‚è∞ Notification suppressed due to quiet hours');
    }
    
    console.log('‚úÖ Periodic sync completed successfully');
  } catch (error) {
    console.error('‚ùå Periodic sync error:', error);
  }
};

// Register periodic background sync
sw.addEventListener('periodicsync', (event) => {
  console.log('üì≤ Periodic sync event received:', event.tag);
  
  if (event.tag === SYNC_TAG) {
    event.waitUntil(handlePeriodicSync());
  }
});

// Handle notification clicks
sw.addEventListener('notificationclick', (event) => {
  console.log('üîî Notification clicked:', event.action);
  
  event.notification.close();
  
  if (event.action === 'dismiss') {
    return;
  }
  
  // Open the app when notification is clicked
  event.waitUntil(
    sw.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // If app is already open, focus it
        for (const client of clientList) {
          if (client.url.includes(sw.registration.scope) && 'focus' in client) {
            return client.focus();
          }
        }
        // Otherwise open a new window
        if (sw.clients.openWindow) {
          return sw.clients.openWindow('/');
        }
      })
  );
});

// Handle service worker activation
sw.addEventListener('activate', (event) => {
  console.log('‚úÖ Service Worker activated');
  event.waitUntil(sw.clients.claim());
});

// Handle service worker installation
sw.addEventListener('install', (event) => {
  console.log('‚¨áÔ∏è Service Worker installing');
  sw.skipWaiting();
});

console.log('‚úÖ Service Worker loaded with Periodic Background Sync support');
