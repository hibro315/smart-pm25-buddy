/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Declare self as ServiceWorkerGlobalScope
const sw = self;

// Precache all assets generated by Vite build
// This is the placeholder that Workbox will replace with the actual manifest
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Runtime caching for AQICN API
registerRoute(
  ({ url }) => url.origin === 'https://api.waqi.info' || url.hostname === 'api.waqi.info',
  new NetworkFirst({
    cacheName: 'aqicn-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 30, // 30 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Runtime caching for Supabase edge functions
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ========================================
// PERIODIC BACKGROUND SYNC FOR AIR QUALITY
// ========================================

const SYNC_TAG = 'phri-air-quality-sync';
const DB_NAME = 'phri-db';
const STORE_NAME = 'phri';
const NOTIFICATION_TAG = 'phri-alert';

// Helper: Open IndexedDB
const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
  });
};

// Helper: Get notification settings from IndexedDB
const getNotificationSettings = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('notification-settings');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting notification settings:', error);
    return null;
  }
};

// Helper: Check if currently in quiet hours
const isQuietHours = (settings) => {
  if (!settings || !settings.enable_quiet_hours) return false;
  
  const now = new Date();
  const currentTime = now.getHours() * 60 + now.getMinutes();
  
  const [startHour, startMin] = settings.quiet_hours_start.split(':').map(Number);
  const [endHour, endMin] = settings.quiet_hours_end.split(':').map(Number);
  
  const startTime = startHour * 60 + startMin;
  const endTime = endHour * 60 + endMin;
  
  if (startTime <= endTime) {
    return currentTime >= startTime && currentTime < endTime;
  } else {
    // Crosses midnight
    return currentTime >= startTime || currentTime < endTime;
  }
};

// Helper: Get user's last known location from IndexedDB
const getLastLocation = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-location');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting last location:', error);
    return null;
  }
};

// Helper: Get user health profile from IndexedDB
const getHealthProfile = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('health-profile');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting health profile:', error);
    return null;
  }
};

// Helper: Save location to IndexedDB
const saveLocation = async (latitude, longitude, location) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-location',
      latitude,
      longitude,
      location,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving location:', error);
    return false;
  }
};

// Helper: Calculate distance between two coordinates (Haversine formula)
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return R * c; // Distance in meters
};

// Helper: Get current location using Geolocation API
const getCurrentLocation = async () => {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation not supported'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        });
      },
      (error) => {
        console.error('Geolocation error:', error);
        reject(error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000
      }
    );
  });
};

// Helper: Save air quality data to IndexedDB
const saveAirQualityData = async (data) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-air-quality',
      ...data,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving air quality data:', error);
    return false;
  }
};

// Fetch air quality data from edge function
const fetchAirQuality = async (latitude, longitude) => {
  try {
    const response = await fetch('https://mfieephfmgoqszratqhu.supabase.co/functions/v1/get-air-quality', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maWVlcGhmbWdvcXN6cmF0cWh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NDk2NzQsImV4cCI6MjA3OTUyNTY3NH0.0SU8y29BS6IcT8on5l2U9JD74zafNPBK0CVLCse84fQ'
      },
      body: JSON.stringify({ latitude, longitude })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching air quality:', error);
    return null;
  }
};

// Get previous air quality data from IndexedDB
const getPreviousAirQuality = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-air-quality');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting previous air quality:', error);
    return null;
  }
};

// Check if notification should be triggered based on AQI thresholds and settings
const shouldNotify = (aqi, userProfile, previousAqi, hasLocationChanged, settings) => {
  // Check quiet hours
  if (isQuietHours(settings)) {
    console.log('üîá In quiet hours, skipping notification');
    return { notify: false, reason: 'quiet_hours' };
  }
  
  // Get custom threshold from settings (default 100)
  const threshold = settings?.aqi_threshold || 100;
  
  // Calculate AQI change
  const aqiChange = previousAqi ? Math.abs(aqi - previousAqi) : 0;
  const aqiIncreased = previousAqi ? aqi > previousAqi : false;
  
  // Always notify on location change if AQI exceeds threshold
  if (hasLocationChanged && aqi > threshold) {
    return { notify: true, reason: 'location_change' };
  }
  
  // Notify if AQI is moderate or higher for users with health conditions
  if (userProfile?.conditions && userProfile.conditions.length > 0 && aqi > 50) {
    return { notify: true, reason: 'health_conditions' };
  }
  
  // Notify if AQI significantly increased (>20 points change) 
  if (aqiIncreased && aqiChange > 20) {
    return { notify: true, reason: 'aqi_spike' };
  }
  
  // Notify if AQI exceeds user's threshold (only when it's a new breach)
  if (aqi > threshold && (!previousAqi || previousAqi <= threshold)) {
    return { notify: true, reason: 'threshold_exceeded' };
  }
  
  // Notify on critical levels regardless
  if (aqi > 150) {
    return { notify: true, reason: 'critical_level' };
  }
  
  return { notify: false, reason: null };
};

// Get AQI category and message
const getAQIMessage = (aqi) => {
  if (aqi <= 50) {
    return { 
      category: 'Good', 
      message: 'Good Air Quality',
      thai: '‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏î‡∏µ',
      color: '#00E400'
    };
  } else if (aqi <= 100) {
    return { 
      category: 'Moderate', 
      message: 'Moderate ‚Äì Sensitive groups be aware',
      thai: '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á ‚Äì ‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ß‡∏±‡∏á',
      color: '#FFFF00'
    };
  } else if (aqi <= 150) {
    return { 
      category: 'Unhealthy for Sensitive Groups', 
      message: 'Unhealthy for sensitive groups',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á',
      color: '#FF7E00'
    };
  } else if (aqi <= 200) {
    return { 
      category: 'Unhealthy', 
      message: 'Unhealthy ‚Äì Wear a mask outdoor',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#FF0000'
    };
  } else {
    return { 
      category: 'Very Unhealthy', 
      message: 'Very Unhealthy ‚Äì Avoid outdoor activities',
      thai: '‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#8F3F97'
    };
  }
};

// Show Rich Notification (Shopee-style) with vibration based on AQI
const showAirQualityNotification = async (aqi, location, reason) => {
  try {
    const aqiInfo = getAQIMessage(aqi);
    let title = '';
    let body = '';
    let icon = '/icon-192.png';
    let image = null;
    let vibrate = [300, 100, 300];
    let requireInteraction = false;
    
    // Determine rich notification content based on AQI severity
    if (aqi > 200) {
      title = 'üö® ‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢! ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\n‚ùå ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£\nüò∑ ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å N95\nüè† ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πà‡∏°‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á`;
      vibrate = [500, 200, 500, 200, 500, 200, 500];
      requireInteraction = true;
      icon = '/icon-512.png';
    } else if (aqi > 150) {
      title = '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\n‚è±Ô∏è ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≠‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£\nüò∑ ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á\nüö´ ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢`;
      vibrate = [400, 150, 400, 150, 400, 150, 400];
      requireInteraction = true;
      icon = '/icon-512.png';
    } else if (aqi > 100) {
      title = '‚ö†Ô∏è ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\nüò∑ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å\n‚ö†Ô∏è ‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á`;
      vibrate = [300, 100, 300, 100, 300];
    } else if (reason === 'location_change') {
      title = 'üìç ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\n‚úÖ ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®${aqiInfo.category}`;
      vibrate = [200, 100, 200];
    } else if (reason === 'aqi_spike') {
      title = 'üìà ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\n‚ö†Ô∏è ‡∏Ñ‡πà‡∏≤‡∏ù‡∏∏‡πà‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß\nüò∑ ‡∏Ñ‡∏ß‡∏£‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å`;
      vibrate = [300, 100, 300, 100, 300, 100, 300];
    } else {
      title = `AQI ${aqi} - ${aqiInfo.category}`;
      body = `${aqiInfo.message}\nüìç ${location}\n\n‚úÖ ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á`;
    }
    
    // Create rich notification with Shopee-style formatting
    await sw.registration.showNotification(title, {
      body,
      icon,
      badge: '/icon-192.png',
      image,
      tag: NOTIFICATION_TAG,
      vibrate,
      requireInteraction,
      silent: false,
      renotify: true,
      timestamp: Date.now(),
      data: { 
        aqi, 
        location, 
        category: aqiInfo.category, 
        reason,
        color: aqiInfo.color,
        timestamp: Date.now(),
        url: '/'
      },
      actions: [
        { action: 'view', title: 'üìä ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î', icon: '/icon-192.png' },
        { action: 'map', title: 'üó∫Ô∏è ‡∏î‡∏π‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', icon: '/icon-192.png' },
        { action: 'dismiss', title: '‚ùå ‡∏õ‡∏¥‡∏î' }
      ]
    });
    
    // Additional vibration for critical alerts
    if (aqi > 150 && 'vibrate' in navigator) {
      setTimeout(() => {
        navigator.vibrate(vibrate);
      }, 1000);
    }
    
    console.log('‚úÖ Rich notification shown:', { aqi, location, category: aqiInfo.category, reason, vibrate });
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

// Main periodic sync handler
const handlePeriodicSync = async () => {
  console.log('üîÑ Periodic sync started:', new Date().toISOString());
  
  try {
    // Get current location
    let currentLocation;
    try {
      currentLocation = await getCurrentLocation();
      console.log('‚úÖ Current location:', currentLocation);
    } catch (locError) {
      console.log('‚ö†Ô∏è Could not get current location, using last known');
      const lastLoc = await getLastLocation();
      if (!lastLoc?.latitude || !lastLoc?.longitude) {
        console.log('‚ùå No location data available');
        return;
      }
      currentLocation = {
        latitude: lastLoc.latitude,
        longitude: lastLoc.longitude
      };
    }
    
    // Get previous location and air quality data
    const previousLocationData = await getLastLocation();
    const previousAirQualityData = await saveAirQualityData({ id: 'last-air-quality' });
    
    // Calculate if location changed significantly (>500 meters)
    let hasLocationChanged = false;
    let distanceMoved = 0;
    if (previousLocationData?.latitude && previousLocationData?.longitude) {
      distanceMoved = calculateDistance(
        previousLocationData.latitude,
        previousLocationData.longitude,
        currentLocation.latitude,
        currentLocation.longitude
      );
      hasLocationChanged = distanceMoved > 500; // 500 meters threshold
      console.log(`üìç Distance moved: ${Math.round(distanceMoved)}m, Changed: ${hasLocationChanged}`);
    }
    
    // Fetch air quality data for current location
    const airQualityData = await fetchAirQuality(
      currentLocation.latitude,
      currentLocation.longitude
    );
    
    if (!airQualityData || !airQualityData.pm25) {
      console.log('‚ùå Failed to fetch air quality data');
      return;
    }
    
    console.log('‚úÖ Air quality data fetched:', airQualityData);
    
    // Save location and air quality to IndexedDB
    await saveLocation(
      currentLocation.latitude,
      currentLocation.longitude,
      airQualityData.location
    );
    
    await saveAirQualityData({
      pm25: airQualityData.pm25,
      aqi: airQualityData.aqi,
      location: airQualityData.location || 'Unknown',
      latitude: currentLocation.latitude,
      longitude: currentLocation.longitude
    });
    
    // Get user health profile
    const healthProfile = await getHealthProfile();
    
    // Get notification settings
    const notificationSettings = await getNotificationSettings();
    
    // Check if notification should be triggered based on AQI
    const notificationCheck = shouldNotify(
      airQualityData.aqi,
      healthProfile,
      previousAirQualityData?.aqi,
      hasLocationChanged,
      notificationSettings
    );
    
    if (notificationCheck.notify) {
      await showAirQualityNotification(
        airQualityData.aqi,
        airQualityData.location || '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô',
        notificationCheck.reason
      );
    } else if (notificationCheck.reason === 'quiet_hours') {
      console.log('‚è∞ Notification suppressed due to quiet hours');
    }
    
    console.log('‚úÖ Periodic sync completed successfully');
  } catch (error) {
    console.error('‚ùå Periodic sync error:', error);
  }
};

// Register periodic background sync
sw.addEventListener('periodicsync', (event) => {
  console.log('üì≤ Periodic sync event received:', event.tag);
  
  if (event.tag === SYNC_TAG) {
    event.waitUntil(handlePeriodicSync());
  }
});

// Handle notification clicks with rich actions
sw.addEventListener('notificationclick', (event) => {
  console.log('üîî Notification clicked:', event.action, event.notification.data);
  
  const data = event.notification.data || {};
  
  // Trigger vibration on click for better UX
  if ('vibrate' in navigator) {
    navigator.vibrate([200, 100, 200]);
  }
  
  event.notification.close();
  
  // Handle different action buttons
  if (event.action === 'view') {
    // Open main page with AQI data
    event.waitUntil(
      sw.clients.openWindow('/?aqi=' + (data.aqi || ''))
    );
  } else if (event.action === 'map') {
    // Open map view
    event.waitUntil(
      sw.clients.openWindow('/?view=map')
    );
  } else if (event.action === 'dismiss') {
    // Just close, no action
    console.log('Notification dismissed by user');
    return;
  } else {
    // Default click (no action button) - open the app
    event.waitUntil(
      sw.clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((clientList) => {
          // If app is already open, focus it
          for (const client of clientList) {
            if (client.url.includes(sw.registration.scope) && 'focus' in client) {
              return client.focus();
            }
          }
          // Otherwise open a new window
          if (sw.clients.openWindow) {
            return sw.clients.openWindow(data.url || '/');
          }
        })
    );
  }
});

// Handle push notifications from server (Rich Shopee-style)
sw.addEventListener('push', (event) => {
  console.log('üì¨ Push notification received:', event);
  
  const data = event.data?.json() || {};
  const title = data.title || 'üå´Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®';
  const pm25 = data.data?.pm25 || 0;
  
  // Create rich notification options
  const options = {
    body: data.body || '‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á',
    icon: data.icon || (pm25 > 150 ? '/icon-512.png' : '/icon-192.png'),
    badge: data.badge || '/icon-192.png',
    image: data.image || null,
    tag: data.tag || 'push-notification',
    vibrate: data.vibrate || [400, 150, 400, 150, 400],
    requireInteraction: data.requireInteraction || pm25 > 150,
    silent: false,
    renotify: true,
    timestamp: data.timestamp || Date.now(),
    data: data.data || {},
    actions: data.actions || [
      { action: 'view', title: 'üìä ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î', icon: '/icon-192.png' },
      { action: 'map', title: 'üó∫Ô∏è ‡∏î‡∏π‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', icon: '/icon-192.png' },
      { action: 'dismiss', title: '‚ùå ‡∏õ‡∏¥‡∏î' }
    ]
  };
  
  // Additional vibration for critical alerts
  if (pm25 > 150 && 'vibrate' in navigator) {
    setTimeout(() => {
      navigator.vibrate(options.vibrate);
    }, 500);
  }
  
  event.waitUntil(
    sw.registration.showNotification(title, options)
  );
});

// Handle service worker activation
sw.addEventListener('activate', (event) => {
  console.log('‚úÖ Service Worker activated');
  event.waitUntil(
    Promise.all([
      sw.clients.claim(),
      // Try to register periodic sync on activation
      (async () => {
        if ('periodicSync' in sw.registration) {
          try {
            const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
            if (status.state === 'granted') {
              await sw.registration.periodicSync.register(SYNC_TAG, {
                minInterval: 15 * 60 * 1000 // 15 minutes
              });
              console.log('‚úÖ Periodic sync registered on activation');
            }
          } catch (e) {
            console.log('‚ö†Ô∏è Periodic sync registration failed:', e);
          }
        }
      })()
    ])
  );
});

// Handle service worker installation
sw.addEventListener('install', (event) => {
  console.log('‚¨áÔ∏è Service Worker installing');
  sw.skipWaiting();
});

// Handle background fetch (for browsers that support it)
sw.addEventListener('backgroundfetchsuccess', (event) => {
  console.log('üì• Background fetch succeeded');
  event.waitUntil(handlePeriodicSync());
});

// Handle sync event (one-time sync when back online)
sw.addEventListener('sync', (event) => {
  console.log('üîÑ Sync event received:', event.tag);
  if (event.tag === SYNC_TAG || event.tag === 'aqi-sync') {
    event.waitUntil(handlePeriodicSync());
  }
});

// Message handler for triggering manual sync from app
sw.addEventListener('message', async (event) => {
  console.log('üì© Message received:', event.data);
  
  if (event.data?.type === 'TRIGGER_SYNC') {
    console.log('üîÑ Manual sync triggered from app');
    await handlePeriodicSync();
    if (event.ports[0]) {
      event.ports[0].postMessage({ success: true });
    }
  }
  
  if (event.data?.type === 'UPDATE_LOCATION') {
    const { latitude, longitude, location } = event.data;
    await saveLocation(latitude, longitude, location);
    console.log('üìç Location updated from app');
  }
  
  if (event.data?.type === 'UPDATE_HEALTH_PROFILE') {
    try {
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      await store.put({
        id: 'health-profile',
        ...event.data.profile,
        timestamp: Date.now()
      });
      console.log('üë§ Health profile updated from app');
    } catch (e) {
      console.error('Error saving health profile:', e);
    }
  }
  
  if (event.data?.type === 'UPDATE_NOTIFICATION_SETTINGS') {
    try {
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      await store.put({
        id: 'notification-settings',
        ...event.data.settings,
        timestamp: Date.now()
      });
      console.log('üîî Notification settings updated from app');
    } catch (e) {
      console.error('Error saving notification settings:', e);
    }
  }
});

console.log('‚úÖ Service Worker loaded with Periodic Background Sync + Push Notification support');
