/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Declare self as ServiceWorkerGlobalScope
const sw = self;

// Precache all assets generated by Vite build
precacheAndRoute(sw.__WB_MANIFEST);
cleanupOutdatedCaches();

// Runtime caching for OpenWeatherMap API
registerRoute(
  ({ url }) => url.origin === 'https://api.openweathermap.org',
  new NetworkFirst({
    cacheName: 'openweathermap-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 30, // 30 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Runtime caching for Supabase edge functions
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ========================================
// PERIODIC BACKGROUND SYNC FOR AIR QUALITY
// ========================================

const SYNC_TAG = 'phri-air-quality-sync';
const DB_NAME = 'phri-db';
const STORE_NAME = 'phri';
const NOTIFICATION_TAG = 'phri-alert';

// Helper: Open IndexedDB
const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
  });
};

// Helper: Get user's last known location from IndexedDB
const getLastLocation = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-location');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting last location:', error);
    return null;
  }
};

// Helper: Get user health profile from IndexedDB
const getHealthProfile = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('health-profile');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting health profile:', error);
    return null;
  }
};

// Helper: Save air quality data to IndexedDB
const saveAirQualityData = async (data) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-air-quality',
      ...data,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving air quality data:', error);
    return false;
  }
};

// Fetch air quality data from edge function
const fetchAirQuality = async (latitude, longitude) => {
  try {
    // Get Supabase URL from environment (injected during build)
    const supabaseUrl = 'https://mfieephfmgoqszratqhu.supabase.co';
    const anonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maWVlcGhmbWdvcXN6cmF0cWh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NDk2NzQsImV4cCI6MjA3OTUyNTY3NH0.0SU8y29BS6IcT8on5l2U9JD74zafNPBK0CVLCse84fQ';
    
    const response = await fetch(`${supabaseUrl}/functions/v1/get-air-quality`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${anonKey}`
      },
      body: JSON.stringify({ latitude, longitude })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching air quality:', error);
    return null;
  }
};

// Check if notification should be triggered
const shouldNotify = (pm25, userProfile) => {
  if (!userProfile?.conditions || userProfile.conditions.length === 0) {
    return false;
  }
  
  // Notify if PM2.5 is unhealthy for sensitive groups (>50) or worse
  return pm25 > 50;
};

// Show notification with vibration
const showAirQualityNotification = async (pm25, location, severity) => {
  try {
    const title = severity === 'critical' 
      ? 'üö® ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏†‡∏±‡∏¢! PM2.5 ‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢'
      : '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏Ñ‡πà‡∏≤‡∏ù‡∏∏‡πà‡∏ô‡∏™‡∏π‡∏á';
    
    const body = severity === 'critical'
      ? `‡∏Ñ‡πà‡∏≤‡∏ù‡∏∏‡πà‡∏ô ${pm25} ¬µg/m¬≥ ‡∏ó‡∏µ‡πà ${location} - ‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£!`
      : `‡∏Ñ‡πà‡∏≤‡∏ù‡∏∏‡πà‡∏ô ${pm25} ¬µg/m¬≥ ‡∏ó‡∏µ‡πà ${location} - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å`;
    
    await sw.registration.showNotification(title, {
      body,
      icon: '/icon-192.png',
      badge: '/icon-192.png',
      tag: NOTIFICATION_TAG,
      vibrate: severity === 'critical' ? [300, 100, 300, 100, 300] : [300, 100, 300],
      requireInteraction: severity === 'critical',
      data: { pm25, location, severity, timestamp: Date.now() }
    });
    
    console.log('‚úÖ Notification shown successfully');
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

// Main periodic sync handler
const handlePeriodicSync = async () => {
  console.log('üîÑ Periodic sync started:', new Date().toISOString());
  
  try {
    // Get user's last known location
    const locationData = await getLastLocation();
    if (!locationData?.latitude || !locationData?.longitude) {
      console.log('‚ùå No location data available');
      return;
    }
    
    // Get user health profile
    const healthProfile = await getHealthProfile();
    if (!healthProfile?.conditions || healthProfile.conditions.length === 0) {
      console.log('‚ÑπÔ∏è No health conditions configured, skipping sync');
      return;
    }
    
    // Fetch air quality data
    const airQualityData = await fetchAirQuality(
      locationData.latitude,
      locationData.longitude
    );
    
    if (!airQualityData || !airQualityData.pm25) {
      console.log('‚ùå Failed to fetch air quality data');
      return;
    }
    
    console.log('‚úÖ Air quality data fetched:', airQualityData);
    
    // Save to IndexedDB
    await saveAirQualityData({
      pm25: airQualityData.pm25,
      aqi: airQualityData.aqi,
      location: airQualityData.location || 'Unknown',
      latitude: locationData.latitude,
      longitude: locationData.longitude
    });
    
    // Check if notification should be triggered
    if (shouldNotify(airQualityData.pm25, healthProfile)) {
      let severity = 'moderate';
      if (airQualityData.pm25 > 90) severity = 'critical';
      else if (airQualityData.pm25 > 50) severity = 'high';
      
      await showAirQualityNotification(
        airQualityData.pm25,
        airQualityData.location || '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô',
        severity
      );
    }
    
    console.log('‚úÖ Periodic sync completed successfully');
  } catch (error) {
    console.error('‚ùå Periodic sync error:', error);
  }
};

// Register periodic background sync
sw.addEventListener('periodicsync', (event) => {
  console.log('üì≤ Periodic sync event received:', event.tag);
  
  if (event.tag === SYNC_TAG) {
    event.waitUntil(handlePeriodicSync());
  }
});

// Handle notification clicks
sw.addEventListener('notificationclick', (event) => {
  console.log('üîî Notification clicked');
  
  event.notification.close();
  
  // Open the app when notification is clicked
  event.waitUntil(
    sw.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // If app is already open, focus it
        for (const client of clientList) {
          if (client.url.includes(sw.registration.scope) && 'focus' in client) {
            return client.focus();
          }
        }
        // Otherwise open a new window
        if (sw.clients.openWindow) {
          return sw.clients.openWindow('/');
        }
      })
  );
});

// Handle service worker activation
sw.addEventListener('activate', (event) => {
  console.log('‚úÖ Service Worker activated');
  event.waitUntil(sw.clients.claim());
});

// Handle service worker installation
sw.addEventListener('install', (event) => {
  console.log('‚¨áÔ∏è Service Worker installing');
  sw.skipWaiting();
});

console.log('‚úÖ Service Worker loaded with Periodic Background Sync support');
