/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Declare self as ServiceWorkerGlobalScope
const sw = self;

// Precache all assets generated by Vite build
// This is the placeholder that Workbox will replace with the actual manifest
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Runtime caching for AQICN API
registerRoute(
  ({ url }) => url.origin === 'https://api.waqi.info' || url.hostname === 'api.waqi.info',
  new NetworkFirst({
    cacheName: 'aqicn-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 30, // 30 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Runtime caching for Supabase edge functions
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ========================================
// PERIODIC BACKGROUND SYNC FOR AIR QUALITY
// ========================================

const SYNC_TAG = 'phri-air-quality-sync';
const DB_NAME = 'phri-db';
const STORE_NAME = 'phri';
const NOTIFICATION_TAG = 'phri-alert';

// Helper: Open IndexedDB
const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
  });
};

// Helper: Get notification settings from IndexedDB
const getNotificationSettings = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('notification-settings');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting notification settings:', error);
    return null;
  }
};

// Helper: Check if currently in quiet hours
const isQuietHours = (settings) => {
  if (!settings || !settings.enable_quiet_hours) return false;
  
  const now = new Date();
  const currentTime = now.getHours() * 60 + now.getMinutes();
  
  const [startHour, startMin] = settings.quiet_hours_start.split(':').map(Number);
  const [endHour, endMin] = settings.quiet_hours_end.split(':').map(Number);
  
  const startTime = startHour * 60 + startMin;
  const endTime = endHour * 60 + endMin;
  
  if (startTime <= endTime) {
    return currentTime >= startTime && currentTime < endTime;
  } else {
    // Crosses midnight
    return currentTime >= startTime || currentTime < endTime;
  }
};

// Helper: Get user's last known location from IndexedDB
const getLastLocation = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-location');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting last location:', error);
    return null;
  }
};

// Helper: Get user health profile from IndexedDB
const getHealthProfile = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('health-profile');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting health profile:', error);
    // Try localStorage fallback
    try {
      const stored = localStorage.getItem('healthProfile');
      if (stored) return JSON.parse(stored);
    } catch (e) {
      console.error('Error reading localStorage:', e);
    }
    return null;
  }
};

// Helper: Generate personalized health advice based on profile and AQI
const generatePersonalizedAdvice = (aqi, pm25, healthProfile) => {
  const advice = [];
  const conditions = healthProfile?.chronicConditions || [];
  const dustSensitivity = healthProfile?.dustSensitivity || 'medium';
  const age = healthProfile?.age || 30;
  const hasAirPurifier = healthProfile?.hasAirPurifier || false;
  
  // High risk conditions
  const hasAsthma = conditions.includes('asthma') || conditions.includes('‡∏´‡∏≠‡∏ö‡∏´‡∏∑‡∏î');
  const hasCOPD = conditions.includes('COPD') || conditions.includes('‡∏õ‡∏≠‡∏î‡∏≠‡∏∏‡∏î‡∏Å‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏∑‡πâ‡∏≠‡∏£‡∏±‡∏á');
  const hasHeartDisease = conditions.includes('heart disease') || conditions.includes('‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à');
  const hasAllergy = conditions.includes('allergy') || conditions.includes('‡∏†‡∏π‡∏°‡∏¥‡πÅ‡∏û‡πâ');
  const isHighRisk = hasAsthma || hasCOPD || hasHeartDisease || age > 60 || age < 12;
  
  // Base advice by AQI level
  if (aqi > 200) {
    advice.push('üö® ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÇ‡∏î‡∏¢‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î');
    advice.push('üè† ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡πÉ‡∏´‡πâ‡∏™‡∏ô‡∏¥‡∏ó');
    if (hasAirPurifier) {
      advice.push('üåÄ ‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ü‡∏≠‡∏Å‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤');
    } else {
      advice.push('üí® ‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏ú‡πâ‡∏≤‡∏ä‡∏∏‡∏ö‡∏ô‡πâ‡∏≥‡∏õ‡∏¥‡∏î‡∏ä‡πà‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®');
    }
  } else if (aqi > 150) {
    advice.push('‚ö†Ô∏è ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î');
    advice.push('üò∑ ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å N95 ‡∏´‡∏£‡∏∑‡∏≠ KF94 ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
  } else if (aqi > 100) {
    advice.push('üò∑ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£');
    if (isHighRisk) {
      advice.push('‚ö†Ô∏è ‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏ß‡∏£‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á');
    }
  }
  
  // Condition-specific advice
  if (hasAsthma && aqi > 50) {
    advice.push('üíä ‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏´‡∏≠‡∏ö‡∏´‡∏∑‡∏î: ‡∏û‡∏Å‡∏¢‡∏≤‡∏û‡πà‡∏ô‡∏Ç‡∏¢‡∏≤‡∏¢‡∏´‡∏•‡∏≠‡∏î‡∏•‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡∏ß');
    if (aqi > 100) {
      advice.push('ü©∫ ‡∏´‡∏≠‡∏ö‡∏´‡∏∑‡∏î: ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏¢‡πÉ‡∏à‡∏•‡∏≥‡∏ö‡∏≤‡∏Å ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡∏ö‡∏û‡∏ö‡πÅ‡∏û‡∏ó‡∏¢‡πå');
    }
  }
  
  if (hasCOPD && aqi > 50) {
    advice.push('ü´Å ‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢ COPD: ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å');
    if (aqi > 100) {
      advice.push('üìã COPD: ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡∏±‡∏î SpO2 ‡∏ö‡πà‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‡∏´‡∏≤‡∏Å‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ 92% ‡∏£‡∏µ‡∏ö‡∏û‡∏ö‡πÅ‡∏û‡∏ó‡∏¢‡πå');
    }
  }
  
  if (hasHeartDisease && aqi > 75) {
    advice.push('‚ù§Ô∏è ‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à: ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢‡∏´‡∏ô‡∏±‡∏Å');
    advice.push('üíì ‡∏ß‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡πÅ‡∏•‡∏∞‡∏ä‡∏µ‡∏û‡∏à‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏¢‡∏∞');
  }
  
  if (hasAllergy && aqi > 50) {
    advice.push('ü§ß ‡∏†‡∏π‡∏°‡∏¥‡πÅ‡∏û‡πâ: ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏±‡∏î‡∏à‡∏°‡∏π‡∏Å ‡∏ô‡πâ‡∏≥‡∏°‡∏π‡∏Å‡πÑ‡∏´‡∏•‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô');
    advice.push('üíä ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏ó‡∏≤‡∏ô‡∏¢‡∏≤‡πÅ‡∏Å‡πâ‡πÅ‡∏û‡πâ‡∏ï‡∏≤‡∏°‡πÅ‡∏û‡∏ó‡∏¢‡πå‡∏™‡∏±‡πà‡∏á');
  }
  
  // Age-specific advice
  if (age > 60 && aqi > 75) {
    advice.push('üë¥ ‡∏ú‡∏π‡πâ‡∏™‡∏π‡∏á‡∏≠‡∏≤‡∏¢‡∏∏: ‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏£‡∏≠‡∏á‡∏≠‡∏≤‡∏Å‡∏≤‡∏®');
  }
  
  if (age < 12 && aqi > 75) {
    advice.push('üë∂ ‡πÄ‡∏î‡πá‡∏Å: ‡∏á‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÅ‡∏•‡∏∞‡∏û‡∏µ‡∏≠‡∏µ‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô');
  }
  
  // Sensitivity-specific advice
  if (dustSensitivity === 'high' && aqi > 50) {
    advice.push('‚ö° ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß‡∏ï‡πà‡∏≠‡∏ù‡∏∏‡πà‡∏ô‡∏™‡∏π‡∏á: ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏©');
  }
  
  // General advice
  if (aqi > 50) {
    advice.push('üíß ‡∏î‡∏∑‡πà‡∏°‡∏ô‡πâ‡∏≥‡∏°‡∏≤‡∏Å‡πÜ ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏∑‡πà‡∏°‡πÅ‡∏≠‡∏•‡∏Å‡∏≠‡∏Æ‡∏≠‡∏•‡πå');
  }
  
  return advice.slice(0, 5); // Max 5 advice items
};

// Helper: Save location to IndexedDB
const saveLocation = async (latitude, longitude, location) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-location',
      latitude,
      longitude,
      location,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving location:', error);
    return false;
  }
};

// Helper: Calculate distance between two coordinates (Haversine formula)
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return R * c; // Distance in meters
};

// Helper: Get current location using Geolocation API
const getCurrentLocation = async () => {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation not supported'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        });
      },
      (error) => {
        console.error('Geolocation error:', error);
        reject(error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000
      }
    );
  });
};

// Helper: Save air quality data to IndexedDB
const saveAirQualityData = async (data) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    
    await store.put({
      id: 'last-air-quality',
      ...data,
      timestamp: Date.now()
    });
    
    return true;
  } catch (error) {
    console.error('Error saving air quality data:', error);
    return false;
  }
};

// Fetch air quality data from edge function
const fetchAirQuality = async (latitude, longitude) => {
  try {
    const response = await fetch('https://mfieephfmgoqszratqhu.supabase.co/functions/v1/get-air-quality', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maWVlcGhmbWdvcXN6cmF0cWh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NDk2NzQsImV4cCI6MjA3OTUyNTY3NH0.0SU8y29BS6IcT8on5l2U9JD74zafNPBK0CVLCse84fQ'
      },
      body: JSON.stringify({ latitude, longitude })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching air quality:', error);
    return null;
  }
};

// Get previous air quality data from IndexedDB
const getPreviousAirQuality = async () => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    
    return new Promise((resolve, reject) => {
      const request = store.get('last-air-quality');
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Error getting previous air quality:', error);
    return null;
  }
};

// Check if notification should be triggered based on AQI thresholds and settings
const shouldNotify = (aqi, userProfile, previousAqi, hasLocationChanged, settings) => {
  // Check quiet hours
  if (isQuietHours(settings)) {
    console.log('üîá In quiet hours, skipping notification');
    return { notify: false, reason: 'quiet_hours' };
  }
  
  // Get custom threshold from settings (default 100)
  const threshold = settings?.aqi_threshold || 100;
  
  // Calculate AQI change
  const aqiChange = previousAqi ? Math.abs(aqi - previousAqi) : 0;
  const aqiIncreased = previousAqi ? aqi > previousAqi : false;
  
  // Always notify on location change if AQI exceeds threshold
  if (hasLocationChanged && aqi > threshold) {
    return { notify: true, reason: 'location_change' };
  }
  
  // Notify if AQI is moderate or higher for users with health conditions
  if (userProfile?.conditions && userProfile.conditions.length > 0 && aqi > 50) {
    return { notify: true, reason: 'health_conditions' };
  }
  
  // Notify if AQI significantly increased (>20 points change) 
  if (aqiIncreased && aqiChange > 20) {
    return { notify: true, reason: 'aqi_spike' };
  }
  
  // Notify if AQI exceeds user's threshold (only when it's a new breach)
  if (aqi > threshold && (!previousAqi || previousAqi <= threshold)) {
    return { notify: true, reason: 'threshold_exceeded' };
  }
  
  // Notify on critical levels regardless
  if (aqi > 150) {
    return { notify: true, reason: 'critical_level' };
  }
  
  return { notify: false, reason: null };
};

// Get AQI category and message
const getAQIMessage = (aqi) => {
  if (aqi <= 50) {
    return { 
      category: 'Good', 
      message: 'Good Air Quality',
      thai: '‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏î‡∏µ',
      color: '#00E400'
    };
  } else if (aqi <= 100) {
    return { 
      category: 'Moderate', 
      message: 'Moderate ‚Äì Sensitive groups be aware',
      thai: '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á ‚Äì ‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ß‡∏±‡∏á',
      color: '#FFFF00'
    };
  } else if (aqi <= 150) {
    return { 
      category: 'Unhealthy for Sensitive Groups', 
      message: 'Unhealthy for sensitive groups',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á',
      color: '#FF7E00'
    };
  } else if (aqi <= 200) {
    return { 
      category: 'Unhealthy', 
      message: 'Unhealthy ‚Äì Wear a mask outdoor',
      thai: '‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏™‡∏ß‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#FF0000'
    };
  } else {
    return { 
      category: 'Very Unhealthy', 
      message: 'Very Unhealthy ‚Äì Avoid outdoor activities',
      thai: '‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û ‚Äì ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á',
      color: '#8F3F97'
    };
  }
};

// Show Rich Notification with personalized health advice and vibration based on AQI
const showAirQualityNotification = async (aqi, location, reason, healthProfile = null) => {
  try {
    const aqiInfo = getAQIMessage(aqi);
    let title = '';
    let body = '';
    let icon = '/icon-192.png';
    let image = null;
    let vibrate = [300, 100, 300];
    let requireInteraction = false;
    
    // Get personalized health advice
    const personalizedAdvice = generatePersonalizedAdvice(aqi, aqi, healthProfile);
    const adviceText = personalizedAdvice.length > 0 
      ? '\n\n' + personalizedAdvice.join('\n') 
      : '';
    
    // Check if user has high-risk conditions
    const conditions = healthProfile?.chronicConditions || [];
    const isHighRisk = conditions.some(c => 
      ['asthma', 'COPD', 'heart disease', '‡∏´‡∏≠‡∏ö‡∏´‡∏∑‡∏î', '‡∏õ‡∏≠‡∏î‡∏≠‡∏∏‡∏î‡∏Å‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏∑‡πâ‡∏≠‡∏£‡∏±‡∏á', '‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à'].includes(c)
    ) || (healthProfile?.age && (healthProfile.age > 60 || healthProfile.age < 12));
    
    // Adjust vibration for high-risk users (more intense)
    const riskMultiplier = isHighRisk ? 1.5 : 1;
    
    // Determine rich notification content based on AQI severity
    if (aqi > 200) {
      title = 'üö® ‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢! ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [500, 200, 500, 200, 500, 200, 500].map(v => Math.round(v * riskMultiplier));
      requireInteraction = true;
      icon = '/icon-512.png';
    } else if (aqi > 150) {
      title = isHighRisk ? 'üö® ‡πÄ‡∏£‡πà‡∏á‡∏î‡πà‡∏ß‡∏ô! ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì' : '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏ï‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [400, 150, 400, 150, 400, 150, 400].map(v => Math.round(v * riskMultiplier));
      requireInteraction = true;
      icon = '/icon-512.png';
    } else if (aqi > 100) {
      title = isHighRisk ? '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á' : '‚ö†Ô∏è ‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [300, 100, 300, 100, 300].map(v => Math.round(v * riskMultiplier));
      requireInteraction = isHighRisk;
    } else if (aqi > 50 && isHighRisk) {
      title = 'üìä ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [200, 100, 200, 100, 200];
    } else if (reason === 'location_change') {
      title = 'üìç ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}\n\n‚úÖ ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®${aqiInfo.category}`;
      vibrate = [200, 100, 200];
    } else if (reason === 'aqi_spike') {
      title = 'üìà ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [300, 100, 300, 100, 300, 100, 300];
    } else if (reason === 'health_conditions') {
      title = 'ü©∫ ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì';
      body = `AQI ${aqi} - ${aqiInfo.thai}\nüìç ${location}${adviceText}`;
      vibrate = [250, 100, 250, 100, 250];
    } else {
      title = `AQI ${aqi} - ${aqiInfo.category}`;
      body = `${aqiInfo.message}\nüìç ${location}\n\n‚úÖ ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á`;
    }
    
    // Create rich notification with personalized content
    await sw.registration.showNotification(title, {
      body,
      icon,
      badge: '/icon-192.png',
      image,
      tag: NOTIFICATION_TAG,
      vibrate,
      requireInteraction,
      silent: false,
      renotify: true,
      timestamp: Date.now(),
      data: { 
        aqi, 
        location, 
        category: aqiInfo.category, 
        reason,
        color: aqiInfo.color,
        timestamp: Date.now(),
        url: '/',
        isHighRisk,
        personalizedAdvice
      },
      actions: [
        { action: 'view', title: 'üìä ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î', icon: '/icon-192.png' },
        { action: 'health', title: 'ü©∫ ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û', icon: '/icon-192.png' },
        { action: 'dismiss', title: '‚ùå ‡∏õ‡∏¥‡∏î' }
      ]
    });
    
    // Additional vibration for critical alerts or high-risk users
    if ((aqi > 150 || (aqi > 100 && isHighRisk)) && 'vibrate' in navigator) {
      setTimeout(() => {
        navigator.vibrate(vibrate);
      }, 1000);
      // Extra vibration for very high risk
      if (aqi > 200) {
        setTimeout(() => {
          navigator.vibrate(vibrate);
        }, 3000);
      }
    }
    
    console.log('‚úÖ Personalized notification shown:', { aqi, location, category: aqiInfo.category, reason, isHighRisk, adviceCount: personalizedAdvice.length });
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

// Main periodic sync handler
const handlePeriodicSync = async () => {
  console.log('üîÑ Periodic sync started:', new Date().toISOString());
  
  try {
    // Get current location
    let currentLocation;
    try {
      currentLocation = await getCurrentLocation();
      console.log('‚úÖ Current location:', currentLocation);
    } catch (locError) {
      console.log('‚ö†Ô∏è Could not get current location, using last known');
      const lastLoc = await getLastLocation();
      if (!lastLoc?.latitude || !lastLoc?.longitude) {
        console.log('‚ùå No location data available');
        return;
      }
      currentLocation = {
        latitude: lastLoc.latitude,
        longitude: lastLoc.longitude
      };
    }
    
    // Get previous location and air quality data
    const previousLocationData = await getLastLocation();
    const previousAirQualityData = await saveAirQualityData({ id: 'last-air-quality' });
    
    // Calculate if location changed significantly (>500 meters)
    let hasLocationChanged = false;
    let distanceMoved = 0;
    if (previousLocationData?.latitude && previousLocationData?.longitude) {
      distanceMoved = calculateDistance(
        previousLocationData.latitude,
        previousLocationData.longitude,
        currentLocation.latitude,
        currentLocation.longitude
      );
      hasLocationChanged = distanceMoved > 500; // 500 meters threshold
      console.log(`üìç Distance moved: ${Math.round(distanceMoved)}m, Changed: ${hasLocationChanged}`);
    }
    
    // Fetch air quality data for current location
    const airQualityData = await fetchAirQuality(
      currentLocation.latitude,
      currentLocation.longitude
    );
    
    if (!airQualityData || !airQualityData.pm25) {
      console.log('‚ùå Failed to fetch air quality data');
      return;
    }
    
    console.log('‚úÖ Air quality data fetched:', airQualityData);
    
    // Save location and air quality to IndexedDB
    await saveLocation(
      currentLocation.latitude,
      currentLocation.longitude,
      airQualityData.location
    );
    
    await saveAirQualityData({
      pm25: airQualityData.pm25,
      aqi: airQualityData.aqi,
      location: airQualityData.location || 'Unknown',
      latitude: currentLocation.latitude,
      longitude: currentLocation.longitude
    });
    
    // Get user health profile
    const healthProfile = await getHealthProfile();
    
    // Get notification settings
    const notificationSettings = await getNotificationSettings();
    
    // Check if notification should be triggered based on AQI
    const notificationCheck = shouldNotify(
      airQualityData.aqi,
      healthProfile,
      previousAirQualityData?.aqi,
      hasLocationChanged,
      notificationSettings
    );
    
    if (notificationCheck.notify) {
      await showAirQualityNotification(
        airQualityData.aqi,
        airQualityData.location || '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô',
        notificationCheck.reason,
        healthProfile
      );
    } else if (notificationCheck.reason === 'quiet_hours') {
      console.log('‚è∞ Notification suppressed due to quiet hours');
    }
    
    console.log('‚úÖ Periodic sync completed successfully');
  } catch (error) {
    console.error('‚ùå Periodic sync error:', error);
  }
};

// Register periodic background sync
sw.addEventListener('periodicsync', (event) => {
  console.log('üì≤ Periodic sync event received:', event.tag);
  
  if (event.tag === SYNC_TAG) {
    event.waitUntil(handlePeriodicSync());
  }
});

// Handle notification clicks with rich actions
sw.addEventListener('notificationclick', (event) => {
  console.log('üîî Notification clicked:', event.action, event.notification.data);
  
  const data = event.notification.data || {};
  
  // Trigger vibration on click for better UX
  if ('vibrate' in navigator) {
    navigator.vibrate([200, 100, 200]);
  }
  
  event.notification.close();
  
  // Handle different action buttons
  if (event.action === 'view') {
    // Open main page with AQI data
    event.waitUntil(
      sw.clients.openWindow('/?aqi=' + (data.aqi || ''))
    );
  } else if (event.action === 'map') {
    // Open map view
    event.waitUntil(
      sw.clients.openWindow('/map')
    );
  } else if (event.action === 'health') {
    // Open health advice page
    event.waitUntil(
      sw.clients.openWindow('/chat?tab=health')
    );
  } else if (event.action === 'dismiss') {
    // Just close, no action
    console.log('Notification dismissed by user');
    return;
  } else {
    // Default click (no action button) - open the app
    event.waitUntil(
      sw.clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((clientList) => {
          // If app is already open, focus it
          for (const client of clientList) {
            if (client.url.includes(sw.registration.scope) && 'focus' in client) {
              return client.focus();
            }
          }
          // Otherwise open a new window
          if (sw.clients.openWindow) {
            return sw.clients.openWindow(data.url || '/');
          }
        })
    );
  }
});

// Handle push notifications from server (Rich Shopee-style)
sw.addEventListener('push', (event) => {
  console.log('üì¨ Push notification received:', event);
  
  const data = event.data?.json() || {};
  const title = data.title || 'üå´Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®';
  const pm25 = data.data?.pm25 || 0;
  
  // Create rich notification options
  const options = {
    body: data.body || '‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á',
    icon: data.icon || (pm25 > 150 ? '/icon-512.png' : '/icon-192.png'),
    badge: data.badge || '/icon-192.png',
    image: data.image || null,
    tag: data.tag || 'push-notification',
    vibrate: data.vibrate || [400, 150, 400, 150, 400],
    requireInteraction: data.requireInteraction || pm25 > 150,
    silent: false,
    renotify: true,
    timestamp: data.timestamp || Date.now(),
    data: data.data || {},
    actions: data.actions || [
      { action: 'view', title: 'üìä ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î', icon: '/icon-192.png' },
      { action: 'map', title: 'üó∫Ô∏è ‡∏î‡∏π‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', icon: '/icon-192.png' },
      { action: 'dismiss', title: '‚ùå ‡∏õ‡∏¥‡∏î' }
    ]
  };
  
  // Additional vibration for critical alerts
  if (pm25 > 150 && 'vibrate' in navigator) {
    setTimeout(() => {
      navigator.vibrate(options.vibrate);
    }, 500);
  }
  
  event.waitUntil(
    sw.registration.showNotification(title, options)
  );
});

// Handle service worker activation
sw.addEventListener('activate', (event) => {
  console.log('‚úÖ Service Worker activated');
  event.waitUntil(
    Promise.all([
      sw.clients.claim(),
      // Try to register periodic sync on activation
      (async () => {
        if ('periodicSync' in sw.registration) {
          try {
            const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
            if (status.state === 'granted') {
              await sw.registration.periodicSync.register(SYNC_TAG, {
                minInterval: 15 * 60 * 1000 // 15 minutes
              });
              console.log('‚úÖ Periodic sync registered on activation');
            }
          } catch (e) {
            console.log('‚ö†Ô∏è Periodic sync registration failed:', e);
          }
        }
      })()
    ])
  );
});

// Handle service worker installation
sw.addEventListener('install', (event) => {
  console.log('‚¨áÔ∏è Service Worker installing');
  sw.skipWaiting();
});

// Handle background fetch (for browsers that support it)
sw.addEventListener('backgroundfetchsuccess', (event) => {
  console.log('üì• Background fetch succeeded');
  event.waitUntil(handlePeriodicSync());
});

// Handle sync event (one-time sync when back online)
sw.addEventListener('sync', (event) => {
  console.log('üîÑ Sync event received:', event.tag);
  if (event.tag === SYNC_TAG || event.tag === 'aqi-sync') {
    event.waitUntil(handlePeriodicSync());
  }
});

// Message handler for triggering manual sync from app
sw.addEventListener('message', async (event) => {
  console.log('üì© Message received:', event.data);
  
  if (event.data?.type === 'TRIGGER_SYNC') {
    console.log('üîÑ Manual sync triggered from app');
    await handlePeriodicSync();
    if (event.ports[0]) {
      event.ports[0].postMessage({ success: true });
    }
  }
  
  if (event.data?.type === 'UPDATE_LOCATION') {
    const { latitude, longitude, location } = event.data;
    await saveLocation(latitude, longitude, location);
    console.log('üìç Location updated from app');
  }
  
  if (event.data?.type === 'UPDATE_HEALTH_PROFILE') {
    try {
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      await store.put({
        id: 'health-profile',
        ...event.data.profile,
        timestamp: Date.now()
      });
      console.log('üë§ Health profile updated from app');
    } catch (e) {
      console.error('Error saving health profile:', e);
    }
  }
  
  if (event.data?.type === 'UPDATE_NOTIFICATION_SETTINGS') {
    try {
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      await store.put({
        id: 'notification-settings',
        ...event.data.settings,
        timestamp: Date.now()
      });
      console.log('üîî Notification settings updated from app');
    } catch (e) {
      console.error('Error saving notification settings:', e);
    }
  }
});

console.log('‚úÖ Service Worker loaded with Periodic Background Sync + Push Notification support');
